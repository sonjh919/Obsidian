#Architecture #DDD 

## Domain Event
도메인에서 발생한 모든 변화로, 어떤 문제나 이슈가 발생한 것을 도메인 관점에서 나열한 것이다.

> [!caution]+ 
> + CRUD의 관점에서 보았을 때, CUD 부분만 도메인 이벤트이다.
> 
> 데이터를 읽는 것은 **변화가 일어나지 않았기 때문에** 이벤트가 아니다.
> 데이터가 생성/수정/삭제되는 것은 **변화가 일어났기 때문에** 이벤트이다.

## Event Storming
> [!info]+ 
> Domain Event + Brain Storming → Event Storming

**도메인에서 발생하는 모든 이벤트를 적고 프로젝트에서 최종적인 어떤 결과물이 나올지를 뽑아내는 작업**이다. [[Component]]를 이용하여 설계를 진행한다. 

> [!caution]+ 
> 어떤 설계나 논의할 것이 없을 때까지, 끝까지 진행해야 한다.
# -- 다시 정리 필요 ↓

## Component
Event Storming을 진행하기 전에 먼저 Component의 종류에 대해서 알아야 한다. Component는 시스템 내에서 역할을 수행하는 요소로, 비즈니스 프로세스에서 발생하는 이벤트들과 상호 작용하며 시스템의 동작을 결정하는 요소이다.

![[1. Project/Architecture/Component.png]]
기본 작성 방식
> - p.p 동사로 주어는 한 개만 ( 상품이 조회됨, 상품이 추가됨, 상품이, 삭제됨)
> - 완전히 다른 기능이 아니라면 주어 통합
> - 일어나는 모든 변화를 Domain 관점으로 작성
> - CUD 부분 중 하나가 작성된다면 (ex)수정) 추가와 삭제도 같이 작성
> - 선입견을 가질 수 있는 주어 선택은 지양
> - 나중에 Aggregate로 묶더라도 하나의 도출 domaim 가기 위한 domain Event 들까지도 작성

### Domain Event
Domain Event(p.p형태의 동사) → 과거형으로 적을 것 : 이 사건이 발생했다는 것을 의미
p.p 동사로 주어는 한 개만 ( 상품이 조회됨, 상품이 추가됨, 상품이, 삭제됨)

### Command
현재형으로 작성
행동, 결정 등의 값들에 대한 정의
UI 혹은 API

### Read Model
행위와 결정을 하기 위해 유저가 참고하는 데이터
단순 도메인 이벤트 조회
데이터 프로젝션이 필요 : CQRS 등으로 수집

### Policy
업무 정책 → 이벤트에 대한 반응
조건에 다른 권한 부여. 도메인 이벤트가  policy에 의해 상황에 따른 결과를 받는다.

### Actor
행동 주체(관리자, 전체 회원, 로그인 회원 등). 도메인 이벤트, 커멘드, 리드 모델을 정의하고 정의한다.
최대한 나중에 생각한다.

### Aggregate
 비즈니스 로직 처리의 도메인 객체 덩어리, 객체 덩어리
 유저 인터페이스를 통해 데이터를 소비하고 명령을 실행하여 시스템과 상호 작용
 
### external system
외부 시스템 → 현재 설계하고 있는 도메인 시스템을 제외한 모든 시스템
설계하는 시스템에 포함되지 않지만 필요한 시스템을 의미하는데, 예를 들어 장바구니 시스템에 포함되진 않지만 필요한 상품 시스템이 있다.
시스템 호출을 암시(REST)

### Hotspot
예측되는 Risk

### Definiton
도메인에 대한 용어 등의 설명, 기술

## Event Storming 과정
도메인 이벤트를 다 나열한 후에 커멘드를 붙이고, 정리가 끝나면 뽑는 것이 actor와 agreegate를 하면 좋을 것이다.
도메인 이벤트를 다 일단 적고(나중에 삭제하더라도 일단 policy, 조회도 포함하면 리드 모델 설계 유용),
비슷한 이벤트 끼리 모으고,
 비슷한 것끼리 command, policy 등을 붙이면서 순서를 정해보고,
 그 다음 비슷한 것끼리 agreegate로 묶는다.
 이 agreegate 하나가 git repository가 될 것이고, 
 여러 개의 git reopsitory가 통신하여 하나의 MSA 아키텍쳐를 구성할 것이다.
## 구현 방식
- 데코레이트 패턴
	 - 다른 domain의 정보들을 하나의 독립된 domain으로 새롭게 만들어서 관리한다.
	 - 데코레이션 패턴의 시스템이 문제가 생겨도 본래 domain에 영향을 주지 않는다.
	 - 기존 내용에 추가하거나 가공해서 가지는 것 ex. 상품이 아닌 찜상품 도메인 만드는 것 
- 임베디드 패턴
	 - 기능을 구현하는데에 추가적인 컬럼의 갯수가 많지 않을 때 다른 domain 의 저장 값에 컬럼을 추가한.
- 컴포지트 패턴
	- 다른 domain 들의 정보를 가져와 메모리상에 저장해서 사용한다.
	- 여러가지 도메인을 조합해 새로운 것을 만드는 것 ex. 별도 서비스를 캐싱해서 쓰고 싶어 ! 

데코레이트, 컴포지트 ⇒ 두 가지를 선택하는 것은 시스템에 따라 결정하는 것 

 ### MSA 아키텍쳐 설계 플로우
 ⇒ 의견 수렴을 위해 디자이너, 프론트, 백앤드 개발자 모두 모여서 진행
 
 이벤트 스토밍 → Aggregate → Boris Diagram(각각의 Aggregate가 어떻게 통신하고 어떤 데이터를 주고 받을 지 설계하는 다이어그램) → Snap-E(API, Data, UI(read model), stories(함수), risk(test code에서 점검 할 내용)) → 구현
