#Architecture #DDD 

## Domain Event
도메인에서 발생한 모든 변화로, 어떤 문제나 이슈가 발생한 것을 도메인 관점에서 나열한 것이다.

> [!caution]+ 
> + CRUD의 관점에서 보았을 때, CUD 부분만 도메인 이벤트이다.
> 
> 데이터를 읽는 것은 **변화가 일어나지 않았기 때문에** 이벤트가 아니다.
> 데이터가 생성/수정/삭제되는 것은 **변화가 일어났기 때문에** 이벤트이다.

## Event Storming
> [!info]+ 
> Domain Event + Brain Storming → Event Storming

**도메인에서 발생하는 모든 이벤트를 적고 프로젝트에서 최종적인 어떤 결과물이 나올지를 뽑아내는 작업**이다. [[Component]]를 이용하여 설계를 진행한다. 

> [!caution]+ 
> 어떤 설계나 논의할 것이 없을 때까지, 끝까지 진행해야 한다.
# -- 다시 정리 필요 ↓

기본 작성 방식
> - p.p 동사로 주어는 한 개만 ( 상품이 조회됨, 상품이 추가됨, 상품이, 삭제됨)
> - 완전히 다른 기능이 아니라면 주어 통합
> - 일어나는 모든 변화를 Domain 관점으로 작성
> - CUD 부분 중 하나가 작성된다면 (ex)수정) 추가와 삭제도 같이 작성
> - 선입견을 가질 수 있는 주어 선택은 지양
> - 나중에 Aggregate로 묶더라도 하나의 도출 domaim 가기 위한 domain Event 들까지도 작성
## Event Storming 과정
도메인 이벤트를 다 나열한 후에 커멘드를 붙이고, 정리가 끝나면 뽑는 것이 actor와 agreegate를 하면 좋을 것이다.
도메인 이벤트를 다 일단 적고(나중에 삭제하더라도 일단 policy, 조회도 포함하면 리드 모델 설계 유용),
비슷한 이벤트 끼리 모으고,
 비슷한 것끼리 command, policy 등을 붙이면서 순서를 정해보고,
 그 다음 비슷한 것끼리 agreegate로 묶는다.
 이 agreegate 하나가 git repository가 될 것이고, 
 여러 개의 git reopsitory가 통신하여 하나의 MSA 아키텍쳐를 구성할 것이다.
## 구현 방식
- 데코레이트 패턴
	 - 다른 domain의 정보들을 하나의 독립된 domain으로 새롭게 만들어서 관리한다.
	 - 데코레이션 패턴의 시스템이 문제가 생겨도 본래 domain에 영향을 주지 않는다.
	 - 기존 내용에 추가하거나 가공해서 가지는 것 ex. 상품이 아닌 찜상품 도메인 만드는 것 
- 임베디드 패턴
	 - 기능을 구현하는데에 추가적인 컬럼의 갯수가 많지 않을 때 다른 domain 의 저장 값에 컬럼을 추가한.
- 컴포지트 패턴
	- 다른 domain 들의 정보를 가져와 메모리상에 저장해서 사용한다.
	- 여러가지 도메인을 조합해 새로운 것을 만드는 것 ex. 별도 서비스를 캐싱해서 쓰고 싶어 ! 

데코레이트, 컴포지트 ⇒ 두 가지를 선택하는 것은 시스템에 따라 결정하는 것 

 ### MSA 아키텍쳐 설계 플로우
 ⇒ 의견 수렴을 위해 디자이너, 프론트, 백앤드 개발자 모두 모여서 진행
 
 이벤트 스토밍 → Aggregate → Boris Diagram(각각의 Aggregate가 어떻게 통신하고 어떤 데이터를 주고 받을 지 설계하는 다이어그램) → Snap-E(API, Data, UI(read model), stories(함수), risk(test code에서 점검 할 내용)) → 구현
