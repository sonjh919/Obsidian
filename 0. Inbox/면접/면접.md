발표 시작하겠습니다.
목차는 다음과 같습니다. 저는 객체지향의 기본 개념부터 시작하여 solid 원칙이 어떻게 유도되는지를 중심으로 설명드리겠습니다.

1
첫번째는 역할과 책임, 협력입니다. 저는 카페를 예시로 들어 설명드리도록 하겠습니다.
카페에 제일 처음 들어가면 커피를 주문해야겠죠? **직원이 손님에게 커피를 주문하라는 요청을 보내고, 손님은 이에 응답함으로써 객체 간 협력이 일어나게 됩니다.**
이때, 이렇게 요청과 응답으로 이루어진 것을 메시지라고 합니다. 또한 손님은 커피를 주문해야 할 책임이 있다고 할 수 있습니다.

커피 주문이 완료되면 실세계에서는 직원이 직접 커피를 만들지만, 여기는 객체지향세계이기 때문에 직원은 커피 객체에게 직접 생성하라라고 요청을 보내는데
이는 객체가 자율성을 가지기 때문입니다. 커피 객체는 요청에 맞는 행동을 취하여 응답하게 됩니다.

직원과 손님은 계산에 대해서도 협력 관계를 가지는데요, 이때 손님은 커피를 주문해야할 책임과 계산해야할 책임을 가지고 있습니다. 이러한 책임들의 집합을 역할이라고 하고,
대체 가능성이라고도 말할 수 있습니다. 어떤 사람이 들어가도 손님의 역할을 훌륭히 수행할 수 있기 때문입니다.

여기서 중요한 점은 설계를 코드를 담는 클래스의 관점이 아니라 메시지를 주고받는 객체의 관점으로 봐야 한다는 것입니다.

2
다음은 커피 객체를 추상화와 관련지어 설명드리겠습니다.
저는 추상화를 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이라고 생각합니다. 복잡성의 정도에 따라 일반화와 특수화로 나누어집니다.
**커피를 필요한 재료에 따라 분류**해 보았는데요, 이렇게 공통의 특징을 공유하는 대상들의 분류를 타입이라고 합니다.
일반화에 가까우면 슈퍼 타입, 특수화에 가까우면 서브타입이라고 합니다. **또한, 이렇게 타입이 층을 나누는것 처럼 보인다 하여 타입 계층**이라고 불립니다.

3
이전 페이지에서 복잡성을 다루기 위한 방법으로 추상화를 말씀드렸는데, 객체지향에서 추상화를 다루는 방법은 캡슐화입니다.
객체는 크게 두가지로 나뉠 수 있습니다. 변경 가능성이 높은 구현 부분과, 메시지의 집합인 인터페이스 부분이죠. 구현 부분은 캡슐화되어 변경의 영향을 통제받고,
추상화된 인터페이스 영역은 외부로 노출되어 다른 객체와 협력하게 됩니다. 이는 곧 인터페이스에 대해 프로그래밍하라 라는 말과 **상통**하죠.

이렇게 된다면 일단 캡슐화가 향상되게 됩니다. 그러면 결합도가 감소하고 응집도가 증가하는데요, 결합도란 다른 모듈에 대해 얼마나 많은 지식을 가지고 있는지 입니다.
즉, 캡슐화가 향상되면 다른 객체에 대한 지식이 줄어들 수 밖에 없죠.
응집도는 내부 요소들이 연관되어 있는 정도로, 변경의 이유라고도 합니다. **캡슐화가 향상되니 내부 요소의 연관성이 올라가죠.**
**즉 결합도가 감소하고 응집도가 증가하면 객체는 한 가지의 변경 이유만** 가지게 됩니다. 이는 다른 말로 하나의 책임만 가진다는 말이고, 이는 단일 책임 원칙으로 **귀결**될 수 있습니다.
단일 책임 원칙을 적용하면 유지보수성이 증가하게 됩니다.

정리하자면, 변경될 수 있는 어떤 것이라도 캡슐화해야 한다는 것입니다.

4
이번에는 의존성에 대해 이야기해보겠습니다.
객체지향적인 설계에 의존성관리는 반드시 필요합니다. 저는 의존성을 함께 변경될 수 있는 가능성이라고 생각하는데요,
조금 더 쉽게 설명하자면 A가 B에 의존하면, B가 변경되면 A도 변경된다는 것입니다.

커피를 계산하는 예시를 한번 생각해보겠습니다. 이때, **커피값에 금액 할인 정책이 적용**된다고 가정하겠습니다. 하지만 만약에, 금액 할인 정책이 수정사항이 생기거나
다른 할인 정책을 추가한다면 어떻게 될까요? 하위 수준 클래스인 금액 할인 정책의 변경으로 상위 수준 클래스인 커피까지 변경되는 것은 **잘못된 구조**입니다.
즉 하위 수준의 변경으로 상위 수준이 변경되어서는 안되고, 이것을 의존성 역전 법칙이라고 합니다.

우리는 이 문제를 해결하기 위해서 추상화에 의존해야 합니다. 할인 정책이라는 추상 클래스를 만들어 커피가 의존하게 만들고, 구체 클래스를 만들어 상속받게 하는 것이죠.
이렇게 된다면 **정책에 대한 캡슐화도 적용되며, 의존성 역전 법칙도 만족할 수 있게 됩니다.**

이때, **새로운 할인 정책**을 추가한다고 생각해봅시다. **할인 정책은 성공적으로 확장**될 수 있고, 이과정에서 **원래 있던 정책들은 수정하지 않아도 되는데요,**
이것은 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다는 개방 폐쇄 원칙을 만족한다고 볼 수 있습니다.

5
그런데 이런 구조에서 2가지 의문점이 생길 수 있습니다. 첫번째는 상위 수준 클래스는 추상 클래스를 의존하고 있어 하위 수준 클래스를 모르는데, 어떻게 협력하지?라는 의문점입니다.
**이것은 런타임 의존성을 확인해보면 알 수 있는데요**, 컴파일타임 의존성에서는 추상 클래스에 의존하고 있지만 런타임 의존성에서는 각 구체 클래스에 정공적으로 의존하고 있습니다.
이때 컴파일타임 의존성에서 런타임의존성으로 바꾸는 것을 의존성을 해결한다고 하고, 생성자, setter, 메서드 실행 인자를 사용하여 해결할 수 있습니다.

6
두번째 의문점은 객체생성책임에 따른 의존성입니다. 사실 구체화된 클래스도 객체의 생성은 꼭 필요한데, 상위 클래스인 커피에서 생성을 담당하게 된다면 **의존성이 생겨 추상 클래스로**
**빼는 이유가 없어집니다**. 이는 객체의 생성과 사용을 분리하여 해결할 수 있습니다.
이렇게 커피 객체는 사용만 하고, 객체를 생성을 목적으로 하는 객체를 따로 만드는 것입니다. 이때 이 객체를 팩토리라고 하며, 이것은 디자인 패턴 중 팩토리 패턴이라고 합니다.

이렇게 외부 객체가 인스턴스 생성 후 이를 전달해 의존성을 해결하는 방식을 의존성 주입이라고 합니다.
생성자 주입, setter 주입, 메서드 주입의 방식이 있는데 spring에서는 변경 가능성을 고려하여 생성자 주입을 택하고 있습니다.

**이번엔 이 구조를 다형성의 입장에서 한번 보겠습니다.** 
커피 객체가 요청을 보내면 **할인 정책의 입장에서는 금액할인 정책을 적용해도 되고, 비율 할인 정책을 적용해도 됩니다.** 
즉, 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력인 다형성을 만족한다고 볼 수 있습니다.
이것을 **코드 레벨**로 보면, 부모 클래스타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당해도 정상적으로 작동되는 것을 알 수 있는데, 이것을 업캐스팅이라고 합니다.
업캐스팅이 가능한 이유는 메시지를 처리할 메서드를 컴파일 시점이 아닌 실행 시점에 결정하는 동적 바인딩 때문입니다.
이 동적 바인딩은 자동적인 메시지 위임을 통한 동적 메서드 탐색에 의해 이루어집니다.
self참조는 메시지 수신 객체부터 탐색하며, super참조는 메시지 수신 객체의 부모클래스부터 탐색합니다.
**이 구조는 개방 폐쇄 원칙을 만족한다고도 했는데요,** 개방 폐쇄 원칙이 목적이라면 업캐스팅과 동적 바인딩은 목적에 이르는 방법 정도로 생각하면 될 것 같습니다.

7
**저는 실제 프로젝트에서 해당 구조의 필요성을 느끼고 이를 적용해보았습니다.** 요구사항은 여러 곳에서 로그인이 가능하게 하는 것이었는데요,
**이에 저는 컨트롤러가 추상 클래스인 로그인서비스에 의존하도록 했습니다. 그 후 카카오서비스와 네이버서비스를 만들어 로그인 서비스를 상속받게 했습니다.**
**팩토리에서는 api 요청이 들어오면 provider를 확인하여 이에 맞는 구체 클래스를 연결해주어 성공적으로 로그인 서비스를 구현한 경험이 있습니다.**

8
상속에 대해 이야기해보도록 하겠습니다.
상속의 목적은 두가지입니다. 먼저 코드를 재사용하는 역할이 있고, 이를 서브클래싱이라고도 합니다. 하지만 코드 재사용은 상속보다는 합성에 더 어울리는 방식입니다.

사실 상속의 핵심 목적은 타입 계층의 구축입니다. 이를 서브타이핑이라고도 합니다.
서브타이핑의 조건에는 대체 가능성과 행동 호환성 두가지가 있는데, 이를 한번 알아보도록 하겠습니다.

10
대체 가능성은 간단합니다. 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다는 것인데요, 펭귄은 새로 간주되므로 대체 가능성을 만족한다고 볼 수 있습니다.

11
행동 호환성은 다음과 같습니다. 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대하면 두 타입을 타입 계층으로 묶을 수 있다는 것입니다.
클라이언트의 관점에서 새는 날 수 있어야 한다고 한다면, 펭귄은 날 수 없기 때문에 새이지만 행동 호환성을 만족한다고 볼 수 없습니다.

12
사실 이 행동 호환성과 대체 가능성, 두 관점을 함쳐서 리스콜프 치환 원칙이라고 부릅니다.
새와 펭귄은 대표적인 리스코프 치환 원칙을 위반하는 사례라고 할 수 있는데요, 이는 클라이언트 사용 목적에 따른 인터페이스 분리를 통해 해결할 수 있습니다.
새는 걷고 날 수 있어야 한다고 했을 때, 나는 것을 담당하는 인터페이스와 걷는 것을 담당하는 인터페이스를 따로 분리하는 것입니다.

13
이렇게 되면 클라이언트 1의 입장에서는 나는 것을 원하기 때문에 **걷는 것에 대한 의존성이 사라지게 됩니다.** 즉, 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않으며
이것을 인터페이스 분리 원칙이라고 합니다.

인터페이스가 분리된다면 외부에 노출되는 인터페이스가 최소화되므로, 곧 인터페이스 최소주의 원칙이라고도 할 수 있습니다.
또한 인터페이스가 최소화되면 **응집도가 올라가므로** 단일 책임 원칙과도 연관이 있다고 볼 수 있습니다.

14
solid 원칙을 정리해보겠습니다. 해당 인터페이스는 하나의 변경 이유를 가져 단일 책임 원칙을 만족합니다.
구체 클래스는 확장에 열려있고, 수정에 닫혀있기 때문에 개방-폐쇄 원칙을 만족하고, 펭귄과 walker는 대체 가능성과 행동 호환성을 만족하기 때문에 리스코프 치환 원칙을 만족합니다.
또한 인터페이스가 의존성에 따라 분리되었기 때문에 인터페이스 분리 원칙이 적용되었고, 마지막으로 추상화에 의존하고 있기 때문에 의존성 역전 법칙을 만족하게 됩니다.

15
디자인패턴과 프레임워크에 대해 이야기해보겠습니다. 디자인패턴은 설계를 재사용하고, 프레임워크는 코드와 설계를 같이 재사용하는 것이라고 생각합니다.
중요한 것은 이들을 설계하고, 적용시키면서 나만의 설계 기준을 확립하여 최종적으로는 oop의 목표인 유지보수가 뛰어난 프로그램을 만드는 것이 목표입니다.

**제가 실제로 사용했던 디자인 패턴**을 한번 가져와봤습니다. 2개 이상의 도메인에서 서비스를 사용하는 경우, service 내 복잡도가 증가하고 의존성도 복잡하게 됩니다.
이에 저는 서비스들을 파사드패턴으로 묶어서 사용했습니다. 이에 복잡도가 감소하고, 유지보수성이 증가하는 것을 경험했습니다.

이것도 파사드패턴으로 볼 수 있는데요, 저는 service와 entity 사이에 강한 결합이 있는 것이 맘에 들지 않았습니다. 왜냐하면 만약 jpa가 아니라 mybatis나 jdbc 등으로 바꾼다고 가정했을 때
repo뿐만 아니라 service도 같이 변경되어야 하기 때문입니다. 그래서 저는 사이에 model이라는 레이어를 추가하여 둘의 의존성을 분리시켰습니다.
이 경우에는 유지보수성이 증가하였지만, 반대로 가독성은 감소한 것을 경험하였는데요, **저는 여기서 객체지향은 트레이드오프가 중요하다는 사실을 알았습니다.**

제가 좋아하는 말들과 함께 발표 마치겠습니다. 감사합니다.
