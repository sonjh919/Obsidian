---
title: 06 메시지와 인터페이스
date: 2024-01-15 12:15
categories:
  - OOP
  - 오브젝트
tags:
  - OOP
  - 객체지향
  - 개발서적
image: 
path:
---
어플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다.

## 협력과 메시지 : 클라이언트-서버 모델
두 객체 사이의 협력 관계를 설명하기 위한 전통적인 메타포로 클라이언트-서버 모델을 들고 왔다. 이 예시를 듣자마자 책이 이야기하고자 하는 바를 단숨에 이해함과 동시에 내가 또 한 단계 나아갔다는 생각이 들었다. 그동안 어떻게 보면 백엔드 내에서만 객체지향을 생각하고 있었는데 어플리케이션 전체로 넓히니 프론트와 백엔드와의 관계도 API라는 메시지를 통해서 협력을 주고받기 때문에 객체지향적이라고 할 수 있는 것 같다. 덕분에 보다 넓은 시야로 프로그램을 다시 바라볼 수 있게 되었다.


## 메시지 전송
메시지 전송(패싱)은 메시지 수신자, 오퍼레이션명, 인자의 조합이다.
메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메소드라고 한다.

```
// 수신자.오퍼레이션명(인자)
condition.isSatisfiedBy(screening);
```

계산을 **메시지와 메서드로 분리하고 실행 시간에 수신자의 클래스에 기반에서 메시지를 메서드에 바인딩하는 것**은 작은 변화처럼 보이지만 커다란 차이를 만든다!
## 퍼블릭 인터페이스와 오퍼레이션
**메시지가 객체의 품질을 결정한다.**
### 퍼블릭 인터페이스
객체가 의사소통을 위해 외부에 공개하는 **메시지의 집합**

### 오퍼레이션
프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지, 수행 가능한 어떤 **행동에 대한 추상화**

UML의 공식 정의는 **실행하기 위해 객체가 호출될 수 있는 변환이나 정의에 관한 명세**이다.
인터페이스의 각 요소는 오퍼레이션이다. 오퍼레이션은 구현이 아닌 추상화이며, 메서드는 오퍼레이션을 구현한 것이다. 메서드는 오퍼레이션과 관련된 알고리즘 또는 절차를 명시한다.

### 시그니처
오퍼레이션(메서드)의 이름과 파라미터 목록(명세)을 합쳐 시그니처(signature)라고 한다.
오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것
메서드는 시그니처에 구현을 더한 것.


## 인터페이스와 설계 품질
좋은 인터페이스는 **최소한의 인터페이스**와 **추상적인 인터페이스**를 만족해야 한다.
최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다.
추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다.(how/what)

이 둘을 만족시키기 위한 가장 좋은 방법은 **책임 주도 설계**이다. 물론 이것도 좋지만, 훌륭한 인터페이스의 공통적인 특징을 아는 것도 중요하다.

### 디미터 법칙
협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이다.
객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 것이다.

**"낯선 자에게 말하지 말라"**
**"오직 인접한 이웃하고만 말하라"**

디미터 법칙을 따르면 부끄럼타는코드(shy code)를 작성할 수 있다. 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다.

디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다. 캡슐화는 클래스 내부의 구현을 감춰야 한다는 사실을 강조한다면 디미터 법칙은 **협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한**한다.

> 무지성으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수도 있다.
{: .prompt-warning }
#### 기차 충돌
메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환하는 요소에 대해 연쇄적으로 메시지를 전달하는 것. 내가봐도 보기 싫은 코드이다... getter의 향연이란...
```java
screening.getMovie().get~.get~
```

사실 디미터의 법칙과 "묻지 말고 시켜라" 두 내용이 같다고 착각하고 있었다. 하지만 이 책을 보니 다르다는 것을 알았다. 그런데 이번 팀 프로젝트를 하면서 설계에 대해서 고민하다 보니 어느새 이 두 개념에 대해 자연스럽게 깨닫고 적용시킨 것을 알았다. 내가 공부를 하고 적용시켜 보는 것 보다 **먼저 고민해본 후 적용시킨 다음에 공부하는 과정에서 해당 개념이 이미 있던 것임을 깨닫고 정리하는 과정**. 내가 원하는 이상적인 공부를 하고 있는 것 같아 기분이 좋다.

### 묻지 말고 시켜라
훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다.

**절차적인 코드는 정보를 얻은 후에 결정한다. 객체지향 코드는 객체에게 그것을 하도록 시킨다.**

### 의도를 드러내는 인터페이스