#jpa

## 값 타입
값 타입은 다음 3가지로 나눌 수 있다.

> [!summary]+ 
> 1. 기본값 타입
> + 자바 기본 타입(int, double, ...)
> + 래퍼 클래스(Integer, ...)
> + String
> 2. 임베디드 타입(복합 값 타입)
> 3. 컬렉션 값 타입


## 1. 기본 값 타입
가장 단순하다. 자바에서 제공하는 기본값 타입이며, String, int 등이 있을 수 있다. **식별자 값도 없고**, **생명주기도 엔티티에 의존**한다. 또한 **공유하면 안된다.**

### 부작용
공유 참조로 인해 발생하는 버그는 정말 찾아내기 어렵다. 이처럼 뭔가를 수정했는데 전혀 예상하지 못한 곳에서 문제가 발생하는데, 이것을 부작용이라고 한다. 이를 막기 위해서는 **값을 복사**하여 사용하자.
## 2. 임베디드 타입
새로운 값 타입을 직접 정의해서 사용할 수 있는데, JPA에서는 이를 임베디드 타입이라 한다. **임베디드 타입도 값 타입이다.** [[@Embedded]]를 이용하여 설정한다.

> [!note]+ 특징
> + 임베디드 타입은 기본 생성자가 된다.
> + 임베디드 타입을 포함한 모든 값 타입은 엔티티 생명주기에 의존한다. 즉 엔티티와 임베디드 타입의 관계를 UML로 표현하면 컴포지션(composition, 합성) 관계가 된다.

> [!attention]+ 
> 하이버네이트는 임베디드 타입을 **컴포넌트(component)**라고 한다.

### 임베디드 타입과 테이블 매핑
임베디드 타입은 엔티티의 값일 뿐이기 때문에, 값이 속한 엔티티의 테이블에 매핑한다.
![[embeded.png]]

> [!tip]+ 
> 잘 설계된 ORM 어플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다.

### 같은 임베디드 타입 : 속성 재정의
+ 만약 같은 임베디드 타입을 가지고 있는 컬럼이 있으면 어떨까? 테이블에 매핑하는 컬럼명이 중복된다는 문제점이 있는데, 이 경우에는 [[@AttributeOverride]]를 이용하여 매핑정보를 재정의해야 한다.
```java
@Entity
public class Member {

	@Id @GeneratedValue
	private Long id;
	private String name;

	@Embeded Address homeAddress;
	@Embeded Address companyAddress;
}
```

> [!check]+ 
> @AttributeOverride를 사용하면 어노테이션을 너무 많이 사용하여 엔티티 코드가 지저분해진다. 하지만 다행히 한 엔티티에 같은 임베디드 타입을 중복해서 사용하는 일은 많지 않다.

> [!tip]+ 
> 임베디드 타입이 null이면 매핑한 컬럼 값은 모두 null이 된다.

### 부작용
임베디드 타입도 마찬가지로 값을 복사하여 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다. 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입(primitive type)이 아니라 **객체 타입**이라는 것이다.

물론 객체를 대입할 때마다 인스턴스를 복사해서 대입하면 공유 참조를 피할 수는 있다. 문제는 **복사하지 않고 원본의 참조 값을 직접 넘기는 것을 막을 방법이 없다는 것**이다.