 + 디자인 패턴 추가하기..
### 키워드
캡슐화
자율성
메시지
역할,책임,협력
연결완전성

협력 : 요청과 응답
대체 가능한 역할과 책임 : 다형성

객체는 충분히 협력적이어야 한다.(토끼 31) -> 전지전능한 객체(x)
객체는 충분히 자율적이어야한다. -> 스스로를 결정하고 책임져야 한다.

객체 공동체에 속한 객체들은 공동의 목표를 달성하기 위해 협력에 참여하지만 스스로의 결정과 판단에 따라 행동하는 자율적인 존재

객체지향 설계의 묘미 : 다른 객체와 조화롭게 협력할 수 있을 만큼 충분히 개방적인 동시에 협력에 참여하는 방법을 스스로 결정할 수 있을 만큼 충분히 자율적인 객체들의 공동체 설계

객체지향의 목표 : 실세계 모방(x) 실세계 창조(o) -> "자율성"

객체는 다른 객체가 무엇을 수행하는지는 알 수 있지만 어떻게 수행하는지에 대해서는 알 수 없다.

자율성 : 자신의 자신의 상태를 직접 관리하고 상태를 기반으로 스스로 판단하고 행동할 수 있음

과거 개발 : 데이터와 프로세스를 분리
객체지향 : 데이터와 프로세스를 객체라는 하나의 틀 안에 묶어서 자율성 보장

-> 쉬운 유지보수와 재사용이 용이한 시스템 구축 가능성 up

---

객체 : 상태와 행동을 함께 지닌 실체 (+식별자)
행동은 상태에 대해 의존적이다.

상태 : 과거의 행동 이력 == 특정 시점에 객체가 가지고 있는 정보의 집합
상태를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식 이해 가능 -> 복잡성 줄이고 인지 과부화 줄이기

"자율적인 객체는 스스로 자신의 상태를 책임지기"

행동 : 객체 자신의 상태를 변경시키는 것
객체의 행동은 상태에 영향을 받는다. 객체의 행동은 상태를 변경시킨다.

협력과 행동 : 어떤 객체도 섬이 아니다. 객체는 다른 객체와 상호작용하며 협력하는 객체들의 공동체에 참여하기 위해 노력한다.

협력하는 유일한 방법 : 메시지
즉, 객체가 어떤 행동을 하도록 만드는 것은 객체가 외부로부터 수신한 메시지

객체 행동의 부수효과(side effect)
객체 자신의 상태 변경
행동 내에서 협력하는 다른 객체에 대한 메시지 전송

즉, 행동 : 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동

하지만, 메시지를 전달한다고 해서 송신자가 수신자에 대한 상태 변경을 예상하지는 못함 -> 캡슐화
캡슐화 -> 자율성 up

식별자 : 객체를 구성할 수 있는 프로퍼티
동등성 : 상태를 이용해 두 값이 같은지 판단
동일성 : 식별자를 기반으로 객체가 같은지를 판단 -> 식별자는 상태 변경에 독립적이므로 객체 판단 가능

객체는 상태를 가지며 상태는 변경 가능하다.
객체의 상태를 변경시키는 것은 객체의 행동이다.
	행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
	행동의 순서가 실행 결과에 영향을 미친다.
객체는어떤 상태에 있더라도 유일하게 식별 가능하다.

쿼리 -> 객체의 상태 조회
명령(command) : 객체의 상태를 변경하는 작업

상태를 중심으로 객체를 바라보지 말고 행동을 중심으로 바라보기!(65p)
객체지향 설계
협력 -> 행동 -> 객체
#### 메서드 메시지 분리
메서드 : 메시지를 처리하는 방법

객체에게 메시지를 전송하면 결과적으로 메시지에 대응되는 특정 메서드가 실행 -> 메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다.

외부의 요청 표현 : 메시지, 요청 처리 방법 : 메서드 / 둘을 분리하는 것은 객체의 자율성을 높이는 핵심 메커니즘 -> 캡슐화

본질(p.35)

#### 클래스지향  vs 객체지향
클래스 : 새로운 개념의 데이터 추상화 제공
객체지향의 핵심은 적절한 책임을 수행하는 역할 간의 유연하고 견고한 협력 관계를 구축하는 것.
클래스는 협력에 참여하는 객체를 만드는 데 필요한 구현 메커니즘일 뿐이다.

클래스 구조와 메서드가 아니라 객체의 역할, 책임, 협력에 집중하자.
코드를 담는 클래스의 관점 -> 메시지를 주고받는 객체의 관점

클래스는 분류에 대한 개념이지 실체가 아니다. 객체는 실체다.

#### 객체란?
인간이 분명하게 인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 어떤 것

---

추상화
추상화 : 현실에서 불필요한 부분을 도려내가면서 사물의 놀라운 본질을 드러내게 하는 과정(지하철노선도)
분류 : 특정 객체를 특정 개념의 객체 집합에 포함시키거나 포함시키지 않는 것

타입도 어떻게 보면 추상화다(90) : 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰지기 때문

어떤 객체가 어떤 타입(개념)에 속하는지를 결정하는 것은 객체가 수행하는 행동이다.
객체의 내부적인 표현은 외부로부터 철저하게 감춰진다.

객체를 분류하기 위해 타입을 결정한 후 프로그래밍 언어를 이용해 타입을 구현할 수 있는 한 가지 방법이 클래스

상속 -> 어디까지 일반화를 하냐

---
오버라이딩 vs 오버로딩 : 메시지가 다르잖아? 오버로딩은 다형성이 아니지

메시지 전송 : 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것
메시지는 협력을 위해 한 객체가 다른 객체로 접근할 수 있는 유일한 방법

책임과 메시지의 수준이 같지는 않다. 책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것. 책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할되는 것이 일반적이다.

역할 : 동일한 메시지를 수신 -> 동일한 책임을 수행 -> 협력의 추상화

객체지향의 핵심은 클래스를 어떻게 구현할 것인가가 아니라 객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지

객체지향 설계란 어플리케이션의 기능을 구현하기 위한 협력 관계를 고안하고, 협력에 필요한 역할과 책임을 식별한 후 이를 수행할 수 있는 적절한 객체를 식별해 나가는 과정

"올바른 책임을 올바른 객체에게 할당하는 것"

책임 주도 설계는 가장 널리 받아들여지는 객체지향 설계 방법
책임주도설계(132p) 객체의 책임과 상호작용에 집중

디자인 패턴은 책임-주도 설계의 결과를 표현 (GOF 디자인패턴)

TDD : 테스트를 작성하는 것이 아니라 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것

---

다형성 : 동일한 메시지라 하더라도 서로 다른 방식의 메서드를 이용해 처리할 수 있다 -> 대체 가능성
다형성은 수신자의 종류를 캡슐화(수신자의 종류를 몰라도 메시지를 전송할 수 있기 때문)
해당 역할을 수행할 수 있다면 어떤 객체든 상관없다
서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것

즉, 다형성은 송신자와 수신자 간의 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춤으로써 달성된다.

객체가 자율적이기 위해 객체에게 할당되는 책임의 수준 역시 자율적이어야 한다.

메시지(what)-메서드(how) 어떤 메서드를 선택할 것인지는 전적으로 수신자의 결정에 좌우된다.
"메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다"

what-who 사이클

묻지말고시켜라

인터페이스 : "객체가 수신할 수 있는 메시지의 목록"

객체지향의 힘은 객체의 외부와 내부를 명확하게 분리하는 것에서 나온다.
인터페이스와 구현의 분리 원칙

---
상속 : 재사용, 확장

abstract vs interface
abstract : 클래스간의 연관 관계를 구축, 확장
### 명언
어떤 객체도 섬이 아니다

객체지향 패러다임은 지식을 추상화하고 추상화한 지식을 객체 안에 캡슐화함으로써 실세계 문제에 내재된 복잡성을 관리하려고 한다. 객체를 발견하고 창조하는 것은 지식과 행동을 구조화하는 문제다.

---

SOLID
[[05 객체 지향 설계 5원칙 - SOLID]]