given, when, then을 분리하는 것이 맞을까?
String 이름 쓰기 싫은데,,

tdd 방법
- 실패하는 작은 단위 테스트를 작성한다. 처음에는 컴파일조차 되지 않을 수 있다.
- 빨리 테스트를 통과하기 위해 프로덕션 코드를 작성한다. 이를 위해 정답이 아닌 가짜 구현 등을 작성할 수도 있다.
- 그 다음의 테스트 코드를 작성한다. 실패 테스트가 없을 경우에만 성공 테스트를 작성한다.
- 새로운 테스트를 통과하기 위해 프로덕션 코드를 추가 또는 수정한다.
- 1~4단계를 반복하여 실패/성공의 모든 테스트 케이스를 작성한다.
- 개발된 코드들에 대해 모든 중복을 제거하며 리팩토링한다.

출처: [https://mangkyu.tistory.com/182](https://mangkyu.tistory.com/182) [MangKyu's Diary:티스토리]

console.readline 뜯어보기
1. 실패하는 단위 테스트 만들기
![[Pasted image 20241016211350.png]]
2. 가짜 구현
![[Pasted image 20241016211053.png]]
![[Pasted image 20241016220112.png]]
컨트롤러 : 입력 데이터의 유효성 검사 , 해석해서 모델을 조작



## 1017
예외처리를 인풋에서 한번에 끝낼 수 없다.
"^//[^\\d,:]\\n\\d+([,:]\\d+)*$"


//;\n1는 string //;\\n1와 같다!

\n 매칭하려면 \\\\n으로..


기본 구분자를 커스텀 구분자로 지정하려는 경우에는 예외가 발생한다 -> 제외

private를 테스트할 상황이 오면 설계를 잘못한 거다!!

1020
void 메서드를 테스트해야하나? mock은 캡슐화를 깨트리지 않나?


![[Pasted image 20241020171612.png]]

dto...?


과제 진행 소감에는 미션을 진행하면서 느끼고 배운 점, 많은 시간을 투자한 부분 등도 포함하면 더 좋을 것 같습니다. 🙂

 저는 이번 미션에서의 목적을 다음과 같이 정했고, 이 부분에 많은 시간을 투자하였습니다.
"구현 전 각 객체의 책임을 명확하게 정의하고, 이를 토대로 TDD를 적용시켜보자!

1. 기능 목록 작성하기
README로 구현 기능 목록을 작성했습니다. 저는 이 목록이 곧 메시지의 목록이라고 생각하고 이를 토대로 테스트를 만들기 시작했습니다.

2. 메시지 정의와 테스트 만들기
먼저 처음에는 문자열을 입력받아야 했으니, "문자열을 입력받아라"라는 메시지를 정의하고, 바로 테스트 코드를 만들었습니다. 그 다음 메시지에 대한 성공 테스트를 만들고, 예외들을 최대한 생각하여 여러 개의 실패 테스트를 만들었습니다. 그 다음 일단 테스트를 통과하도록 만들기 위해 가짜 구현을 했습니다. 문자열을 입력받는 책임을 가진 객체가 필요하다고 생각했고, inputview객체를 만든 후 예외처리 예시들을 넣어 단순 문자열 비교로 테스트를 통과하도록 했습니다.

3. 검증을 하려면 비즈니스로직으로 들어가야 한다?
이제 진짜 기능을 구현하기 위해서 코드를 작성하기 시작했는데, 사실 문자열을 입력받는 것 자체는 쉬웠지만 미리 작성해놓았던 검증 테스트를 통과하게 만드는 것이 정말 어려웠습니다. 커스텀 구분자를 포함하여 올바른 구분자를 사용하였는지 검증하려면, 커스텀 구분자를 추출해내는 비즈니스 로직이 필요했기 때문이었습니다. 정규표현식을 이용하여 해결해보려 했지만 실패했고, 결국 입력받은 직후 모든 검증을 하는 것은 불가능하다고 판단했습니다. 그래서 일단 입력 부분만 구현 후 다음 과정으로 넘어갔습니다.

3. 어떤 객체가 어떤 책임이 필요할까?
비즈니스 로직인 구분자 추출, 숫자 추출, 합 계산 로직 3개의 메시지가 나왔으니 어떤 객체가 어떤 책임이 필요할지 고민했습니다. 첫 번째는 문자열을 이용해 구분자를 추출하는 책임과, 숫자를 추출하는 책임이 있었습니다. 두 책임을 엮어 문자열을 전처리하는 역할로 볼 수 있다고 생각하여 StringHandler 객체를 만들었습니다. inputview 객체를 만들 때 만들었던 예외처리 테스트들을 StringHandler 객체로 이동시켰습니다. 추출된 구분자와 기본 구분자를 컬렉션에 보관해야 했고, 이에 일급 컬렉션을 사용하여 Delimiters 객체를 만들었습니다. 또한 숫자들을 저장하는 컬렉션을 생각해 역시 일급 컬렉션으로 Numbers 객체를 만들었습니다. 그런데 합 계산 로직을 생각하면서 문제가 생겼습니다.

4. 상태보다는 행동을 먼저 생각하기..!
처음에 합을 계산하는 로직은 당연히 계산기라고 생각하여 Calculator 객체를 생각했는데, 이 객체에서 합을 계산하려면 Numbers 객체의 필드를 가져와야 해 캡슐화가 무너지는 상황이 생겼습니다. 다시 돌아보니 이는 상태를 먼저 생각하고 행동을 보려고 하니 하나의 객체가 두 개로 나뉘어져서 일어난 일인 것 같았습니다. 그래서 Numbers 객체에 합 계산 로직을 포함시키는 방향으로 수정하였습니다.

5. 다시 테스트와 구현 시작!
객체 간 협력 구상도 끝냈으니 이에 맞는 테스트를 만들고, 구현을 하였습니다. 이때 Controller에서 다른 객체들을 조율하지만, 생성하는 책임은 없다고 생각하고 각 객체에 대해 정적 팩토리 메서드를 적용하였습니다.

TDD 후기
그동안 책으로 객체지향에 대한 이론 공부를 하는 것이 위주였는데, 실제로 적용해 볼 수 있는 기회가 있어서 정말 좋았습니다. 역시 이론을 실전에 적용시키는 것은 난이도가 높다는 사실을 알았고, 내 생각보다 훨씬 많은 상황이 엉켜 있어 객체 간 협력을 정확하게 정의하지 않는다면 구현 과정에서 힘들어진다는 것을 배웠습니다. 객체지향적인 설계에 대해 많은 것을 생각해 볼 수 있는 미션이었고, 중간중간 설계에서 막힐 때마다 힌트를 얻기 위해 살짝씩 구현을 했다 보니 TDD를 성공적으로 적용시켰다고 말하기는 어려운 것 같습니다. 다음 미션에서는 조금 더 설계를 연습하고, 난이도가 높아지는 만큼 디자인 패턴을 공부하고, 적극적으로 적용시켜보고 싶습니다.


