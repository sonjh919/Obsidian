#Architecture #DDD #개발서적 #jpa 


## 엔티티와 밸류 기본 매핑 구현
애그리거트와 JPA 매핑을 위한 기본 규칙은 다음과 같다.

> [!summary]+ 
> 1. 애그리거트 루트는 엔티티이므로 [[@Entity]]로 매핑 설정한다.
> 2. 한 테이블에 엔티티와 밸류 데이터가 같이 있다면, 밸류는 [[@Embeddable]]로 매핑 설정한다.
> 3. 밸류 타입 프로퍼티는 [[@Embedded]]로 매핑 설정한다.
> 4. 필요하다면 [[@AttributeOverride]]를 이용해 매핑 정보를 재정의한다.


> [!example]+ 
> ```java
> @Embeddable
> public class Orderer {
> 	// MemberId에 정의된 칼럼 이름을 변경하기 위해
> 	// @AttributeOverride 애노테이션 사용
> 	@Embedded
> 	@AttributeOverrides(
> 		@AttributeOverride(name = "id", column = @Column(name = "orderer_id"))
> 	)
> 	private MemberId memberId;
> 
> 	@Column(name = "orderer_name")
> 	private String name;
> 
> 	...
> }
> ```


[[기본 생성자]]
[[필드 접근 방식 사용]]

## AttributeConverter를 이용한 밸류 매핑 처리
구현방식에 따라 밸류 타입의 프로퍼티를 한 개 칼럼에 매핑해야 할 때도 있다.

> [!example]+ 
> Length가 길이 값과 단위의 두 프로퍼티를 갖고 있는데 DB 테이블에는 한 개 칼럼에 '1000mm'와 같은 형식으로 저장할 수 있다.

이와 같은 경우 @Embeddable로는 처리할 수 없는데, 이때 사용할 수 있는 것이 AttributeConverter이다. AttributeConverter를 이용해 **밸류 타입과 칼럼 데이터 간의 변환을 처리**할 수 있다.

```java
package javax.persistence;

public interface AttributeConverter<X,Y> {
	public Y convertToDatacaseColumn(X attribute);
	public X convertToEntityAttribute(Y dbData);
}
```

+ 타입 파라미터 X는 밸류 타입이고, Y는 DB 타입이다.
+ AttributeConverter 인터페이스를 구현한 클래스는 @Converter 어노테이션을 적용한다.
+ @Converter 애노테이션의 autoApply 속성값을 true로 지정했는데 이 경우 모델에 출현하는 모든 Money 타입의 프로퍼티에 대해 MoneyConverter를 자동으로 적용한다.
```java
@Converter(autoApply = true)
public class MoneyConverter implements AttributeConverter<Money, Integer> {

	@Override
	public Integer convertToDatabaseColumn(Money money) {
		if(money == null) return null;
		else return money.getValue();
	}

	@Override
	public Money convertToEntityAttribute(Integer value) {
		if(value == null) return null;
		else return new Money(value);
	}
}
```

+  @Converter의 autoApply 속성이 false인 경우 프로퍼티값을 변환할 때 사용할 컨버터를 직접 지정할 수 있다.
```java
public class Order {

	@Column(name = "total_amounts")
	@Convert(converter = MoneyConverter.class)
	private Money totalAmounts;
	...
}
```

## 밸류 컬렉션: 별도 테이블 매핑
밸류 컬렉션을 별도 테이블로 매핑할 때는 [[@ElementCollection]]과 [[@CollectionTable]]을 함께 사용한다.

> [!question]+ JPA 컬렉션?
> [[컬렉션 래퍼]]


```java
@Entity
@Table(name = "purchase_order")
public class Order {
	...
	@ElementCollection
	@CollectionTable(name = "order_line",
										joinColumns = @JoinColumn(name = "order_number"))
	@orderColumn(name = "line_idx")
	private list<OrderLine> orderLines;
}

@Embeddable
public class OrderLine {
	@Embedded
	private ProductId productId;
	...
}
```

## 밸류 컬렉션: 한 개 칼럼 매핑
밸류 컬렉션을 별도 테이블이 아닌 한 개 칼럼에 저장해야 할 때가 있다. 예를 들어, 도메인 모델에는 이메일 주소 목록을 Set으로 보관하고 DB에는 한 개 컬럼에 콤마로 구분해서 저장해야 할 때가 있다. 이때 AttributeConverter를 사용하면 밸류 컬렉션을 한 개 칼럼에 쉽게 매핑할 수 있다. 단, AttributeConverter를 사용하려면 밸류 컬렉션을 표현하는 새로운 밸류 타입을 추가해야 한다.

```java
public class EmailSet {
	private Set<Email> emails = new HashSet<>();

	private EmailSet() {}
	private EmailSet(Set<Email> emails) {
		this.emails.addAll(emails);
	}

	public Set<Email> getEmails() {
		return Collections.unmodifiableSet(emails);
	}
}
```

```java
@Converter
public class EmailSetConveter implements AttributeConveter<EmailSet, String> {
	@Override
	public String convertToDatabaseColumn(EmailSet attribute) {
		if(attribute == null) return null;
		return attribute.getEmails().stream()
						.map(Email::toString)
						.collect(Collectors.joining(","));
	}
	@Override
	public EmailSet convertToEntityAttribute(String dbData) {
		if(dbData == null) return null;
		String[] emails = dbData.split(",");
		Set<Email> emailSet = Arrays.stream(emails)
						.map(value ->  new Email(value))
						.collect(toSet());
		return new EmailSet(emailSet);
	}
}
```

```java
@Column(name = "emails")
@Convert(converter = EmailSetConverter.class)
private EmailSet emailSet;
```

## 밸류를 이용한 아이디 매핑
식별자는 보통 문자열이나 숫자와 같은 기본 타입을 사용한다. 이 방법도 나쁘지 않지만 식별자라는 의미를 부각시키기 위해 식별자 자체를 별도 밸류 타입으로 만들 수도 있다. 이때 @Id 대신 [[@EmbeddedId ]]애노테이션을 사용한다. 

> [!caution]+ 
> JPA 에서 식별자 타입은 Serializable 타입이어야 하므로 식별자로 사용될 밸류 타입은 Serializable 인터페이스를 상속받아야 한다.

밸류 타입으로 식별자를 구현할 때 얻을 수 있는 장점은 식별자에 기능을 추가할 수 있다는 점이다.

> [!example]+ 
> 1세대 시스템의 주문번호와 2세대 시스템의 주문번호를 구분할 때 주문번호의 첫 글자를 이용한다고 해보자. 다음과 같이 OrderNo 클래스에 시스템 세대를 구분할 수 있는 기능을 구현할 수 있다.
> 
> ```java
> @Embeddable
> public class OrderNo implements Serializable {
> 	@Column(name = "order_number")
> 	private String number;
> 
> 	public boolean is2ndGeneration() {
> 		return number.startsWith("N");
> 	}
> 	...
> }
> ```