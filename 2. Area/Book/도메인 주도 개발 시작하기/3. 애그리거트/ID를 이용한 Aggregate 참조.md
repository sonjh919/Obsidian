#Architecture #DDD #개발서적 


## Aggregate 참조
애그리거트 간의 참조는 필드를 통해 쉽게 구현할 수 있다. JPA를 사용하면 [[@ManyToOne]], [[@OneToOne]]과 같은 애노테이션을 이용해서 연관된 객체를 로딩하는 기능을 제공하고 있으므로 필드를 이용해서 다른 애그리거트를 쉽게 참조할 수 있다. 하지만 필드를 이용한 애그리거트 참조는 다음의 문제를 야기할 수 있다.

> [!summary]+ 
> + 편한 탐색 오용
> + 성능에 대한 고민
> + 확장 어려움

### 1. 편한 탐색 오용
한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다. 다음 코드처럼 구현의 편리함 때문에 다른 애그리거트를 수정하고자 하는 유혹에 빠지기 쉽다.

> [!caution]+ 
> 한 애그리거트 내부에서 다른 애그리거트에 접근할 수 있으면, 구현이 쉬워진다는 것 때문에 다른 애그리거트의 상태를 변경하는 유혹에 빠지기 쉽다.

```java
public class Order {
	private Orderer orderer;

	public void changeShippingInfo( ... ) {
		...
		// Member의 Address를 변경한다. 
		orderer.getCusotmer().changeAddress(newShippingInfo.getAddress());
	}
}
```

위와 같이 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트 간의 **의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.**

### 2. 성능에 대한 고민
JPA를 사용할 경우 참조한 객체를 지연로딩과 [[즉시 로딩]]의 두 가지 방식으로 로딩할 수 있다.

### 3. 확장 어려움
초기에는 단일 서버에 단일 DBMS로 서비스를 제공하는 것이 가능하다. 문제는 사용자가 몰리기 시작하면서 도메인별로 시스템을 분리하기 시작한다. 이 과정에서 **하위 도메인마다 서로 다른 DBMS를 사용할 가능성이 높아진다.** 이는 더 이상 다른 [[Aggregate 루트]]를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음을 의미한다.

---

이런 세 가지 문제를 완화할 때 사용할 수 있는 것이 **ID를 이용하여 다른 애그리거트를 참조하는 것**이다. 애그리거트의 경계를 명확히 하고 **애그리거트 간 물리적인 연결을 제거**하게 된다.

> [!summary]+ 
> 1. 모델의 복잡도를 낮춰준다.
> 2. 애그리거트 간의 의존을 제거하므로 응집도를 높여준다.
> 3. 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 원척적으로 방지할 수 있다.
> 4. 애그리거트 별로 다른 구현 기술을 사용하는 것도 가능해진다.

