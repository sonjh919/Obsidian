#Architecture #DDD #개발서적 

## 도메인 서비스
도메인 서비스는 도메인 영역에 위치한 도메인 로직을 표현할 때 사용한다.

도메인 서비스가 도메인 영역의 애그리거트나 밸류와 같은 다른 구성요소와 비교할 때 다른 점이 있다면 **상태 없이 로직만 구현**한다는 점이다. 도메인 서비스를 구현하는 데 필요한 상태는 애그리거트나 다른 방법으로 전달받는다.

> [!summary]+ 
> + 계산 로직 : 여러 애그리거트가 필요한 계산 로직이나, 한 애그리거트에 넣기에는 복잡한 계산 로직
> + 외부 시스템 연동이 필요한 도메인 로직 : 구현을 위해 타 시스템을 사용해야 하는 도메인 로직


### 계산 로직과 도메인 서비스
+ 할인 계산 서비스 (도메인 서비스)
```java
public class DiscountCalculationService {
public Money calculateDiscountAmounts(
		List<OrderLIne> orderLines,
		List<Coupon> coupons,
		MemberGrade grade) {
	Money couponDiscount = coupons.stream()
		.map(coupon -> calculateDiscount(coupon))
		.reduce(Money(0), (v1, v2) -> v1.add(v2));
	Money membershipDiscount = 
		calculateDiscount(orderer.getMember().getGrade());

	return couponDiscount.add(membershipDiscount);
}

...
}
```

+ DiscountCalculationService를 다음과 같이 애그리거트의 결제 금액 계산 기능에 전달하면 사용 주체는 애그리거트가 된다.
```java
public class Order {
	public void calculateAmounts(
			DiscountCalculationService disCalSvc, MemberGrade grade) {
		Money totalAmounts = getTotalAmounts();
		Money discountAmounts = disCalSvc.calculateDiscountAmounts(this.orderLInes, this.coupons, greade);
		this.paymentAmounts = totalAmounts.minus(discountAmounts);
	}
	...
```


**애그리거트 객체에 도메인 서비스를 전달하는 것은 응용 서비스 책임이다.**
```java
public class OrderService {
	private DiscountCalculationService discountCalculationService;

	@Transactional
	public OrderNo placeOrder(OrderRequest orderRequest) {
		OrderNo orderno = orderRepository.nextId();
		Order order = createOrder(orderNo, orderRequest);
		orderRepository.save(order);
		// 응용 서비스 실행 후 표현 영역에서 필요한 값 리턴

		return orderNo;
	}

	private Order createOrder(OrderNo orderNo, OrderRequest orderReq) {
		Member member =findMember(orderReq.getOrdererId());
		Order order = new Order(orderNo, orderReq.gerOrderLines(),
							orderReq.getCoupons(), createOrderer(member),
							orderReq.getShippingInfo());
		order.calculateAmounts(this.discountCalculationService, member.getGrade());
		return order;
	}
	...
}
```

> [!caution]+ 
> 
> 도메인 서비스 객체를 애그리거트에 주입하지 말자.
> 
> 도메인 서비스는 데이터 자체와는 관련이 없다. Order 객체를 DB에 보관할 때 다른 필드와는 달리 저장 대상도 아니다. 또한 Order가 제공하는 모든 기능에서 DiscountCalculationService를 필요로 하는 것도 아니다. 일부 기능만 필요로 한다. 일부 기능을 위해 굳이 도메인 서비스 객체를 애그리거트에 의존 주입할 이유는 없다. 이는 프레임워크의 기능을 사용하고 싶은 개발자의 욕심을 채우는 것에 불과하다.
> 

애그리거트 메서드를 실행할 때 도메인 서비스를 인자로 전달하지 않고 반대로 도메인 서비스의 기능을 실행할 때 애그리거트를 전달하기도 한다. 계좌 이체의 경우가 그런 예제 이다.

> [!example]+ 
> ```java
> public class TransgerService {
> 	public void transfer(Account fromAcc, Account toAcc, Money amounts) {
> 		fromAcc.withdraw(amounts);
> 		toAcc.credit(amounts);
> 	}
> }
> ```

> [!caution]+ 
> 단, 도메인 서비스는 도메인 로직을 수행하지 응용 로직을 수행하지는 않는다. 그러므로 트랜잭션 처리와 같은 로직은 응용 로직이므로 도메인 서비스가 아닌 응용 서비스에서 처리해야 한다.

> [!note]+ 
> 특정 기능이 응용 서비스인지 도메인 서비스인지 감을 잡기 어려울 때는 **해당 로직이 애그리거트의 상태를 변경하거나 애그리거트의 상태 값을 계산하는지** 검사해 보면 된다. 예를 들어, 계좌 이체 로직은 계좌 애그리거트의 상태를 변경한다. 결제 금액 로직은 주문 애그리거트의의 주문 금액을 계산한다. 이 두 로직은 각각 애그리거트를 변경하고 애그리거트의 값을 계산하는 도메인 로직이다. 도메인 로직이면서 한 애그리거트에 넣기 적합하지 않으므로 이 두 로직은 도메인 서비스로 구현하게 된다.