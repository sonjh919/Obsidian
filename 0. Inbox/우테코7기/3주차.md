과제를 수행하면서 느낀 점, 배운 점, 많은 시간을 투자한 부분

저는 2주차 과제를 하면서 가독성을 높여 코드 전체의 퀄리티를 깔끔하게 만들고 싶다는 생각을 했습니다. 정적 팩토리 메서드와 많은 검증 로직, getter 등으로 객체에서 비즈니스 로직 자체가 차지하는 비중이 줄어들었고, 이로 인해 객체를 먼저 보았을 때 객체의 역할을 완벽하게 파악하기 어렵다는 생각이 들었었습니다. 또한 try-catch 같이 반드시 필요하지만 많이 반복되어 가독성을 해친다고 생각하는 것들도 있었습니다. 하지만 앞서 언급한 것들 역시 객체에 필수로 들어가야 하는 책임들이기 때문에, 반복되는 알고리즘에 대한 껍데기만 따로 분리하여 객체를 깔끔하게 만들어 가독성을 보다 높이고자 하였습니다.

함수형 인터페이스의 도입
3주차부터 잘못된 값 입력시 에러 메시지 출력 후 그 부분부터 다시 입력을 받는 요구사항이 추가되었습니다. 이에 모든 입력 메서드에 똑같은 부분을 추가해야 했습니다. 그래서 저는 이 부분이 공통된 로직이라 생각하여, getValidInput라는 정적 메서드를 만들고 Supplier를 이용해 분리했습니다. controller 부분에서 코드의 길이를 상당 부분 줄일 수 있었고, 이로 인해 가독성을 높일 수 있었다고 생각합니다.

검증 로직의 변화
검증 로직의 위치에 대한 부분은 그동안 많은 관점이 있었습니다. 저는 검증 로직은 해당 객체의 필드를 가지고 이루어지는 것이므로, 검증에 대한 책임도 객체가 가져야 한다고 생각했고, 그동안 객체 안에 검증 로직을 넣었습니다. 하지만 이렇게 된다면 만약 여러 객체에서 같은 검증을 할 때에는 코드가 중복될 수도 있고, 검증이 많아지면 그만큼 객체가 커진다는 단점이 있었습니다. 저는 이것을 해결하기 위해 마찬가지로 함수형 인터페이스를 도입했습니다. 이때, 검증 조건을 람다로 받아 검증의 목적이 드러날 수 있게 하였습니다. 또 검증 로직이 많다면 차례대로 검증해야 하는데, 이것을 줄이는 방법은 없을까? 생각하다가 메서드 체이닝이 떠올랐습니다. 그래서 아예 검증 과정 자체를 코드화 할 수 있도록 검증 클래스를 따로 만들고, 이것을 빌더 패턴을 이용하여 메서드 체이닝을 할 수 있도록 변경하였습니다. 여기서 문제점이 하나 있었는데, 여러 곳에서 공통적으로 쓰이게 하기 위해 제네릭을 도입했는데, 숫자 연산(>,사칙연산 등)이 먹히지 않는다는 단점이 있었습니다. 또한 사용자 입력이 문자인지, 숫자인지 검증하는 로직도 필요했기 때문에 결국 제네릭 필드와 정수 필드 2가지를 만들어 상황에 맞게 사용했습니다. 
검증 로직을 빌더 패턴으로 단순화시키니, 각 객체에서 사용할 때 한번에 필요한 검증들을 묶어서 수행하고, 여전히 책임 분리도 가능하며, 가독성도 좋아졌다고 느꼈습니다.

묻지 말고 시켜라
이번 주차에는 확실히 객체에게 책임을 할당하는 과정이 저번 주차보다 익숙해졌다고 생각합니다. 특히 캡슐화에 중점을 두고 생각하니 enum을 제외하면 get으로 땡겨와서 수행하는 일은 거의 없어졌습니다. 
하지만 문제점이 하나 있었는데, 사용자가 산 로또 번호와 당첨 번호를 확인하는 로직에서 두 객체의 필드가 모두 필요한데, 어느 객체에 이 역할을 맡겨야 하나 고민되었었습니다. 현실에서의 로또를 생각할 때, 내 번호가 먼저 확정되고 나중에 나온 당첨 번호를 확인하기 때문에 사용자의 로또 객체에서 결과 확인 로직을 진행하였습니다. 이 때도 당첨번호 객체의 필드를 가져오지 않고, 사용자 로또의 각 숫자가 포함되는지를 다시 당첨 로또 객체로 보내 계산하게 했습니다. 
그런데 이런 설계 때문에 오히려 복잡해지는 부분도 있다고 생각이 들었습니다. 해당 객체가 맡은 역할이지만, 필드는 다른 객체에 있어서 메시지가 2~3단계씩 넘어가는 경우도 있는 것 같습니다. 객체의 책임이 잘 분리되고, 로직이 조금이라도 더 단위로 나누어져 옳은 설계라고 생각하지만 이로 인해 경우에 따라 코드가 불필요하게 많아지는 일도 생길 것 같습니다. 만약 객체가 너무 많아지면, 객체 간 메시지가 거미줄처럼 연결되어 알아보기 힘들겠다는 생각이 들었고, 약 그렇게 된다면 새로운 계층의 도입을 고민하여 거미줄을 좀 푸는 것도 좋은 방법이겠다는 생각이 들었습니다.


테스트의 목적
저는 테스트 작성에 크게 2가지 이유가 있다고 생각합니다. 하나는 코드에 대한 즉각적인 피드백이고, 다른 하나는 설계를 확인받을 수 있다는 것입니다. 먼저 테스트 코드를 짠다면, 여러 경우에 대하여 일일이 실행시켜가며 확인작업을 해야하는 번거로움이 사라지며, 빼먹을 수도 있는 예외들에 대해서도 언제나 확인할 수 있기에 코드 작성에 대한 리소스를 상당히 절약할 수 있다고 생각합니다. 다른 이유는 설계와 관련이 있는데, 이는 TDD와도 연관되어 있습니다. 테스트 코드 작성 자체가 내가 코드의 구조를 알맞게 설계했는지, 그 의도가 맞는지를 확인하는 과정이라고 생각합니다. 단위 테스트를 작성한다면, 내가 작은 기능별로 나누어서 잘 설계했는가를 확인받을 수 있으며, 통합 테스트를 작성한다면 프로그램의 흐름이 내가 의도한 대로 이루어지는가를 확인할 수 있습니다. 이때 내가 예상했던 것과 달리 어떤 비즈니스 로직에서 테스트를 작성하기가 어렵다면 코드 구조가 잘못되었다는 반증이 될 수 있기 때문입니다. 그래서 저는 테스트를 작성하면서 메인 코드를 고치지 않는 것을 목표로 두고 있습니다. 하지만 이번 미션에서 한번 예외를 찾아서 코드를 바꿨는데, 바로 상금 계산을 int로 했다는 것이었습니다. 1등을 2번 했을때의 상금을 계산하니 int의 범위를 넘어가 테스트가 실패하여 상금 계산 부분을 long으로 교체하였습니다. 이렇게 예외를 확인할 수 있다는 것 역시 테스트의 주요 목적 중 하나라고 생각합니다.

이번 주에서는 공통 부분을 많이 빼고, 비즈니스 로직을 최대한 몰아넣어 가독성이 높아지게 만들었습니다. 이런 식으로 개발자가 그때그때 작성해야 될 부분을 점점 줄여 나간다면, 이것이 프레임워크를 만드는 기초가 되지 않을까?라는 생각입니다. 다음주에도 최대한 비즈니스 로직에 대한 가독성을 높이고, 공통 로직을 분리하여 유지보수를 높일 수 있는 방법을 생각하면서 미션을 수행하려고 합니다.