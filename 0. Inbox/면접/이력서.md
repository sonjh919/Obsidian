## Java, Spring 질문
bean : 스프링 컨테이너가 관리하는 자바 객체
bean factory : bean 생성
IOC 컨테이너 : bean 의존성 관리

스프링 삼각형
DI/ioc 의존성 주입과 제어의 역전
AOP 횡단 관심사 분리
PSA 일관성 있는 서비스 추상화(JDBC)
## JPA 질문
jpa-프록시 패턴
[[프록시]]
## DB 질문

## 디자인패턴
어댑터 : 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들을 함께 작동해주도록 변환

프록시 [[Proxy Pattern]] : 대리자
데코레이터 : 장식자, 원본 객체 + 추가 기능 동적
![[Pasted image 20240731143917.png]]
싱글턴 : 단 하나의 유일한 객체
템플릿메서드 : 여러 클래스에서 공통으로 사용하는 메서드를 템플릿화
팩터리메서드 : 객체 생성 분리
전략 패턴 :  실행(런타임) 중에 알고리즘 전략을 선택하여 객체 동작을 실시간으로 바뀌도록
파사드 : 복잡하게 얽혀 있는 것을 정리해서 사용하기 편한 인터페이스를 고객에게 제공

### 실제 쓴 디자인패턴 & 객체지향
파사드패턴 : 서비스에서 다른 도메인의 레포에 의존성을 가져도 되는가?에서 출발
2개 이상의 도메인에서 서비스를 사용하는 경우 서비스들을 파사드패턴으로 묶어서 사용

모델 레이어 추가 : 서비스와 레포의 결합이 너무 강한 것 같다. 지금은 jpa를 쓰지만, 다른 것으로 변경했을 때 서비스도 변경이 필요하여 이를 해결하고자 사이에 모델 레이어를 추가하였다.

## Gradle Multi-Module
Q. api와 implementation 차이
api는 의존성이 전파되지만, implementation는 의존성이 전파되지 않는다.

Q. Web-Application-Domain-Infrastructure
Domain은 인터페이스가 들어가는 자리, Infrastructure는 세부 구현
## ELK 질문
Q. 왜 ELK를 선택했나?
A. queryDSL로 검색했을 때 여러 테이블의 join이 필요하여 검색 속도가 느려지는데, 이를 해결하기 위해 Nosql 기반과 역인덱스를 사용하는 elk를 선택하였다.

Q. ELK 서버가 터진다면?
A. 대응책을 준비하진 못했다. 그러나 똑같이 서버 증설 등으로 해결할 수 있지 않을까 싶다.

Q. 돈이 없다면?
A. 돈이짱이다.. 서버 운영은 진짜 돈이 다다.. 트래픽 분석으로 예상해서 그 상황에서만 증설하기..?

Q. 인덱싱과 역인덱싱
인덱싱 : 책의 앞부분의 목차, 컬럼을 미리 정렬해둔 것
역인덱싱 : 책의 뒷부분의 찾아보기, 키워드로 문서 검색

Q. 왜 역인덱싱이 인덱싱보다 빠른가?
`색인 ( Index )` 같은 경우에 키워드를 찾기 위해 모든 데이터를 조회해야 하는데 `역색인 ( Inverted Index )` 같은 경우에는 해당 키워드에 해당하는 주소값 ( 페이지 ) 만 읽으면 되기 때문에 속도가 빠릅니다.

Q. 공식 개발문서 어렵나?
얘는 그나마 잘 나와 있었다. 다만 deprecated된 것들이 좀 있어서 대체를 찾는 것이 어려웠다.

Q. Custom Analyzer 설명좀
Tokenizer로 Edge-ngram 사용. 이건 **생성된 모든 토큰의 시작 글자를 단어의 시작 글자로 고정시켜서 생성**한다. ex) hello 는 h, he, hel, hell, hello
토큰필터로 stop(불용어 제거), lowercase(다 소문자) 적용
## Webflux 질문
Q. Webflux 선택 이유?
기존 WebMVC의 경우 Tomcat 기반의 Blocking I/O 로 동작하기 때문에 대용량의 트래픽이 몰릴 시 커넥션풀이 부족할 수 있다고 판단하였고, 이를 해결하기 위해서 NonBlocking I/O의 이벤트 기반으로 동작하는 Netty 기반의 WebFlux를 선택하게 되었다.
Non-blocking에 비동기 방식이고, 스레드를 늘리는 MVC와 다르게 이벤트 루프로 실행되어 적은 수의 스레드로 여러 요청 처리 가능

Q. blocking vs nonblocking, sync vs async
[[동기&비동기 vs Blocking&Non-Blocking]]
동기 방식과 비동기 방식의 차이는 **시간의 이슈**이다.
동기 : 작업 순서 보장, 비동기 : 작업 순서 보장x
Blocking 방식과 Non-Blocking 방식의 차이는 **IO의 이슈**이다.
블로킹 : 작업 시작 후 종료시까지 다른 작업 수행 x
넌블로킹 : 작업 시작 후 다른 작업 종료시까지 안기다리고 다른 작업 수행

Q. mono vs flux
mono : 비동기 0-1개의 시퀀스 처리
flux : 비동기 0-N개의 시퀀스 처리

Q. tomcat? netty?
tomcat : 자바 웹 애플리케이션 서버로, 웹 애플리케이션을 실행하기 위한 자바 서블릿 및 JSP(JavaSever Pages)를 지원 / 블로킹, 동기
netty:  비동기 이벤트 기반 네트워크 애플리케이션 프레임워크 / 넌블로킹, 비동기
## Redis 질문
Q. Redis 선택 이유?
인메모리 기반으로 일반적인 DB보다 빠른 속도, 싱글 스레드 기반이기 때문에 동시성 이슈도 해결 가능하고, 삽입 순서를 보장하기 때문에 선택했다.
Q. 왜 sorted set을 썼나?
Sorted set은 일반적인 set 자료구조임과 동시에, score 필드를 기반으로 정렬되어서 저장된다. 이때 score를 timestamp로 설정하면, 삽입 순서를 보장하기 때문에 대기열 순서를 저장할 수 있는 역할을 수행할 수 있다.
Q. Rabbitmq vs redis
알고리즘 자체는 복잡하지 않고, 속도가 중요하며 지속성이 중요하지 않기 때문에 redis를 선택했다.

Q. Websocket vs SSE vs polling
Websocket : 양방향이라 어울리지 않아 탈락
SSE : 처음에 SSE로 구현했으나 프론트단에서 많은 트래픽 발생 시 보안상의 이유로 연결을 끊어버리는 이슈가 생기는데, 이를 해결하려면 중간에 서버를 두어야 해서 polling으로 구현

Q. 전체적인 흐름
1. 프론트에서 요청을 먼저 webflux로 보낸다.
2. Redis queue 2개를 이어붙여, 대기열 큐와 처리열 큐에 각각 대기열을 쌓는다.
3. 초당 N개씩 allow시키고, 프론트에서는 polling방식으로 대기열에서 accept되었는지 확인
4. accept되면 main 서버로 요청을 보내 콘서트 예매 진행

## 동시성 이슈 질문
## 유저 테스트 모니터링 이슈 대응 성능 개선
Q. 실시간 이슈가 뭐가 있었나?
A. 포폴에 있듯이 ELK 서버에서의 api 지연시간 이슈 -> 서버 스케일업 후 메모리 스왑(디스크 공간을 이용한 메모리 대체)

Q. 예상보다 사용자 수가 많아서 서버가 터진다면?
A. ALB와 auto scailing을 이용하여 미리 서버가 트래픽을 감당할수 있도록 한다. 혹시 모를 상황을 대비하여 동적ALB도 준비한다.
## CI/CD aws 설계
Q. CI/CD 구축 방법
A. git Action + Ec2, git Action + beanstalk 2가지로 해봤다.

Q. 사용해본 aws
Iam, Ec2, S3, RDS, beanstalk, ECR, ALB, Auto Scailing, Route 53

Q. VPC란?
VPC(Virtual Private Cloud)는 클라우드 환경을 퍼블릭과 프라이빗의 논리적으로 독립된 네트워크 영역으로 분리할 수 있게 해준다. 어떤 리소스라도 논리적으로 분리된 영역에 격리할 수 있으며, 사용자가 네트워크 환경 설정에 대한 완전한 통제권을 가질 수 있다.

Q. Auto scailing, ALB란?
Auto Scailing : 서버 사이즈를 자동으로 조절
ALb : 서버 트래픽 분산

## DDD
Q. DDD 방식
Event storming
event - external system - command - hotspot - aggregate - actor - context

## 객체지향